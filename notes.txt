View Matrix
Camera:{ 
position "eye" (Vec3)
	{eye sub x, eye sub y, eye sub z}
looking at "target" (Vec3)
up direction "up"} (Vec3)

Z = normalize(eye - target) //target <-- this.position+this.forward
X = normalize(up * Z)		//this.localUp
Y = Z * X


	[Xx	Yx	Zx	0]				[Xx	Xy	Xz	0]
R = [Xy	Yy	Zy	0] --> R^-1 = 	[Yx	Yy	Yz	0]
	[Xz	Yz	Zz	0]				[Zx	Zy	Zz	0]
	[0	0	0	1]				[0	0	0	1]

Position Transformation
	[1	0	0	EYEx]				[1	0	0	-EYEx]
T = [0	1	0	EYEy] --> T^-1 = 	[0	1	0	-EYEy]
	[0	0	1	EYEz]				[0	0	1	-EYEz]
	[0	0	0	1]					[0	0	0	1]

Camera's "world transformation" is translation times rotation
View transform is its inverse: R^-1 * T^-1

[Xx	Xy	Xz	0]		[1	0	0	-EYEx]		[Xx	Xy	Xz	-(eye*x)]
[Yx	Yy	Yz	0]	*	[0	1	0	-EYEy]	=	[Yx	Yy	Yz	-(eye*y)]
[Zx	Zy	Zz	0]		[0	0	1	-EYEz]		[Zx	Zy	Zz	-(eye*z)]
[0	0	0	1]		[0	0	0	1]			[0	0	0		1	]

this.mView = Matrix.view(this.position,this.position+this.forward,this.localUp);


perspectivecamera.js stuff
near: distance to near clip plane (ie the closest visible distance)
far: distance to far clip plane (ie the farthest visible distance)
theta:vertical frield of view(angle between top and bottom of visible space)
a=w/h: aspect ratio - (width of visible space/height of visible space)

theta = this.fov in perspectivecamera, viewRadians in matrix.js
a = aspect in both files

View Space ----Projection Matrix----> Clip Space
Proj Matrix(of the perspective variety):
[1/(atan(theta/2))	0	0	0]
[0	1/(tan(theta/2))	0	0]
[0	0	(n+f)/(n-f)	2nf/(n-f)]
[0	0	-1	0]
this transform will map you from view space to clip space

use float32array, go through elements in columns, 
itll be transposed if you do it in CSVs